## 1. 함수 및 배열

### 1-1. 함수

함수를 쓰는 이유

가독성, 유지보수, 확장 용이

- 종류

  - 표준 함수 : 기본적으로 제공해주는 함수 (print, Array, Math 등등)

  - 사용자 정의 함수

![](https://velog.velcdn.com/images/lcw574/post/9256599c-720a-4490-9b54-caa3439dd804/image.png)

### 1-2. 변수

- 지역변수

  > 특정구역({ }) 내에서 생성되어 그 구역에서만 사용하는 변수

  ```c

  void main(void)
  {
      int val = 0;
      fnc1();
  }

  void fnc1()
  {
      int local = 10;
      fnc2();
  }

  void fnc2()
  {
      int local = 20;
  }
  ```

  라고 했을때 스택 메모리에는 main 변수 - fnc1 변수 - fnc2 변수 순으로 쌓임

  같은 이름이라도 다른 영역의 함수에 속해 있으므로 독립된 다른 변수임

  변수는 해당 함수가 끝나는대로 없어짐

  그러니까 fnc2 - fnc1 - main 순으로 변수가 없어진다는 소리

- 전역변수

  > 함수 바깥에서 선언된 변수

  ```c
  int global; // 전역변수

  void main(void)
  {
      int val = 0; // 지역변수
      fnc1();
  }
  ```

  전역변수는 프로그램이 시작하자마자 메모리에 저장되고 프로그램이 종료될때 소멸

  얘는 `데이터 영역`에 저장됨 (스택, 힙에 되는게 아님)

- 스태틱 변수

  > 지역변수처럼 함수내에서 선언되지만, 함수를 벗어나도 메모리 영역에 저장되어 소멸되지 않음

  프로그램이 처음으로 실행될 때 변수가 초기화되며, 이후로는 초기화가 되지 않음

  ```c
  void func(){
    static int value = 0;
    value ++;
    printf("%d\n", value);
  }

  int main()
  {
    for(int i = 0; i < 5; i++){
    func();
    }

        return 0;

  }
  ```

  이렇게 된다면 1, 1, 1, 1, 1 이 아니라 1, 2, 3, 4, 5 가 됨

### 1-3 배열

> 같은 속성을 가진 것들을 나열해 놓은것

- 초기화

  ```c
  // 선언 및 초기화
  int array1[5] = {1,2,3,4,5};

  // 크기 생략 가능
  int array2[] = {1,2,3,4,5};
  ```

- 배열은 상수(`변수가`)이기 때문에 변경 불가능

  ```c
  // 배열 복사하겠다고 이러면 에러뜸
  int arr1[] = {1, 2, 3, 4, 5};
  int arr2[5];

  arr2 = arr1 // Error

  // 복사하고 싶으면 요소끼리 복사를 해야함
  for(int i = 0; i < 5; i++){
        arr2[i] = arr1[i];
  }
  ```

  js, py 는 그냥 되는데 이러한 과정을 생략한거임 (근데 저러면 얇은 복사 아님?)

- 문자열 배열

  ```c
  char str[] = "Hello World";
  printf("%s\n", str);
  ```

  이러면 공백 포함 총 12개가 저장되는데 마지막에 null 문자까지 해서 12개가 됨

  ※ null 문자에 관하여

  간단히 말하면 **구분** 하기 위해서 있는거임

  `char str[100] = "Beautiful";` 이라는 코드가 있다면 하면

  문자수는 9개 배열은 100개, 91개의 공간이 빔

  91개의 공간에는 쓰레기값으로 채워지지만

  컴퓨터는 어디서부터 어디까지가 쓰레기값이고 실제값인지 구분할수 없음

  그렇기에 null 값을 넣어서 총 10칸을 차지하게 되는거임

  100크기의 str 을 그대로 출력해도 컴퓨터는 null 을 보고 실제 값만 출력해줌

## 2. 포인터

> 정확힌 포인터 변수로 메모리의 주소값을 저장하고 있는 변수

- 사용방법

  ```c
  char *변수; // *가 주소값만 저장하겠는다 (선언)

  // 사용방법
  int b = 100;
  int *pb = &b; // b의 주소값을 pb 에 저장하겠다

  // %p (포인터) 또는 %x (헥사) >> 0x어쩌구저쩌구
  printf("&b 의 값 =  %p\n", pb);

  // 이건 포인트 연산  >> 100 (여기서 * 는 실제값 참조값)
  printf("*pb 의 값 =  %d\n", *pb);

  ```

### 2-1. 배열와 포인터

배열 이름은 해당 배열의 **첫번째 요소**의 주소값을 갖음 (`포인터`)

`arrA` 이름은 `&arrA[0]` 과 같음

배열이름 == 포인터이지만

일반적인 포인터와는 차이점이 있음

바로 위에 언급했듯 상수처럼 변경이 안된다는 점

> 배열의 이름은 주소값을 갖지만 상수이므로 변경 할 수 없다.

### 2-2. 함수와 포인터

함수에 매개변수를 전달하는 형태에는 2개가 있음

- 값에 의한 복사

  ```c
  int a = 10;
  fnc(a); // 실인수

  void fnc(int x){} // a변수의 값 복사해서 저장 (형식인수)
  ```

- 참조에 의한 복사

  배열을 전달인자로 사용할때 포인터 주소값을 복사해서 저장함

  ```c
  void fnc (int *pArr){
    for(int i = 0; i < 5; i++){
        printf("함수 안의 배열 : %d\n", *(pArr + i));
    }
  }
  ```

  이렇게 그냥 주소값을 넘기면 메모리 절약을 할수 있음
