## 1. 클래스

> 사용자 정의 데이터 타입

데이터와 메소드를 사용자인 내가 새로 정의한 데이터타입이기 때문에 클래스를 추상적인 데이터타입이라고 함.

클래스의 본질은 데이터타입, 구조체와 비슷

멤버변수와 멤버 함수로 이루어짐

### 1-1. 접근 지정자

- public : 모두 접근 가능

- protected : 상속 관계에서 접근 가능

- internal : 같은 어셈블리(프로젝트)

- protected internal : protected 와 internal 둘다 포함

- private : 내 클래스 내에서만 접근 가능

### 1-2. 생성

`Dog a = new Dog();`

여기서 new 연산자가 동적 할당으로 힙영역에 메모리를 줌

![](https://velog.velcdn.com/images/lcw574/post/ea4b0e51-4bda-4466-8874-16b1d7bca3fa/image.png)

### 1-3. 생성자

모든 변수는 선언시 값을 초기화해야함

객체도 본질적으로 변수이므로 선언되면 초기화해야함

그 초기화 전용 메소드가 `constructor(생성자)` 임.

객체 생성시 자동으로 호출됨

- 클래스 이름과 동일한 명으로 할것

- 리턴 타입이 없음

### 1-4. 상속

> 객체들 간의 관계를 구축하는 방법

### 1-5 다형성 (오버로딩, 오버라이딩)

- 오버로딩

  함수 이름이 같더라도 전달인자의 타입이나 개수에 따라 다른 객체로 보는것

  ```c
  int Plus(int a, int b){
    return a + b;
  }

  char Plus(char a, char b){
    return a + b;
  }

  int Plus(int a, int b, int c){
    return a + b + c;
  }
  ```

  여기서 내가 넣는 전달인자에 따라 알아서 거기에 맞춰서 실행해줌

- 오버라이딩

  기존의 것을 덮는 것. 상속 관계에서 하는것

### 1-5. 인터페이스

> 메소드 목록만 가지고 있는 명세(Specification), 사용자 정의 타입

메소드 선언만 하고 구현하지는 않음

```c
접근지정자 interface 이름 : 기반 인터페이스{}


접근지정자 class 클래스명 : 인터페이스 {}
```

#### 사용하는 이유

기존의 기능을 추가하거나 수졍의 개념보단,

동일한 개념의 기능을 새롭게 구현하는 기능

공동 작업시 `표준`을 정하는 역활

## 2. 람다

> 메소드를 정의하지 않고 사용할때

- 쓰는 이유

  간결해지고, 코딩 오버헤드를 줄일 수 있음

## 참고

[객체의 생성과 소멸](https://brunch.co.kr/@oemilk/120)
