## 1. 함수 포인터

함수를 포인터처럼 쓸 수 있음

js 에서 함수를 변수에 담는 행위가 바로 함수 포인터임

```c
// 자료형(* 함수 포인터 이름)(전달 인자);
int(*func)(int a);

// 예시
int Plus (int a, int b){
    return a + b;
}
int Minus(int a, int b){
    return a - b;
}

int main()
{
    int a = 20;
    int b = 10;
    int select = 0;

    int (*fptr)(int a, inb);

    while(1)
    {
        scanf("%d", &select);
        // 여기서 Minus 를 박냐 Plus 를 박냐에 따라 값이 달라짐
        switch(select){
            case 1:
                fptr = Plus;
                break;
            case 2:
                fptr = Minus;
                break;
            case 3:
                return 0;
            default:
                break;
        }

        int result = fptr(a, b); // 스위치 값에 따라 결과값이 달라짐
        printf("결과값 : %d\n", result);
    }
}
```

- 사용하는 이유

  메모리 크기 및 위치가 결정되는 시점은 `컴파일 타임(정적 바인딩)` or `런타임 시점(동적 바인딩)`

  동적 바인딩, 정적 바인딩의 대표적인 예는 변수 선언

  `const value = 100;` 값을 보고 크기를 결정함

  `int num = 100;` 이미 정수라고 4바이트 쥐어주고 값을 받음

  vs 코드에서 사용되는 extension들은 **플러그인** 방식으로 동작하는데

  플러그인 방식을 사용하면 새로운 기능을 추가할때마다 매번 컴파일 하지 않아도 된다.

  > 코드의 규격을 정해놓고 함수포인터를 전달해서 동적으로 기능을 추가

  함수 포인터를 사용하면 프로그램의 유연한 `확장성`을 제공한다.

## 2. 구조체

하나 이상의 서로 다른 종류의 변수들을을 묶어서 새로운 데이터 타입을 정의하는 것

![](https://velog.velcdn.com/images/lcw574/post/006aec3e-0e1b-4cbc-9ab9-940df24fabe7/image.png)

접근 방법 : `str1.name`

## 3. 공용체, 열거형

### 3-1. 공용체

구조체와 같은 사용자 정의 자료형

차이점은 `메모리 공간을 공유` 한다는 점

![](https://velog.velcdn.com/images/lcw574/post/57fd43ec-941a-4af4-9a4e-10f35edbd49b/image.png)

근데 이걸 왜씀?

애초에 멤버객체에 쓰임에 맞게 타입을 할당 하자나

4바이트다 1바이트다 하고

근데 거기서 더 아낀다고 공유를 해야할 이유가 있어?

라고 생각했는데 물론 아낄려고 하는 경우도 있고

다양한 형식의 데이터에 접근하기 위한 경우도 있다네

```c
union Data {
    int intValue;
    float floatValue;
    char stringValue[20];
};
```

위의 Data는 다양한 형식의 데이터에 접근하기 위해 사용.

예를 들어, intValue에 접근하면 4바이트의 정수,

floatValue에 접근하면 4바이트의 부동 소수점 수,

stringValue에 접근하면 20바이트의 문자열을 얻을 수 있다고 함

### 3-2. 열거형

enumeration(열거) 의 약자로 enum 이라고 읽음

`연속적`인 데이터들을 열거한 **집합**

컴파일러는 열거형 멤버들을 정수형 상수로 취급한다.

```c
enum DayOfWeek {    // 열거형 정의
    Sunday = 0,         // 초깃값 할당
    Monday,
    Tuesday,
    Wednesday,
    Thursday,     // 중간에 100 을 하면 이후에는 101, 102 가 됨
    Friday,
    Saturday
};
```

## 4. 동적 메모리 할당과 객체지향

메모리는 코드, 스택, 힙, 데이터로 총 4개의 영역으로 구분함

![](https://velog.velcdn.com/images/lcw574/post/705d1673-2de1-4a99-b779-8419e7a940f7/image.png)

- 코드 영역

  실행한 명령어들이 순서대로 쌓임 CPU가 이 영역에서 명령어들을 하나씩 처리함

- 스택 영역

  지역변수, 매개변수등이 쌓임

- 힙 영역

  메모리가 일부 할당되었다가 회수 되는 일들의 반복

  컴파일시가 아닌 사용자로부터 할당 메모리를 입력 받음 (`동적 메모리`)

- 데이터 영역

  전역변수와 static 변수가 저장되는 메모리 영역, 프로그램 종료시 소멸

### 4-1. 동적으로 메모리를 할당하는 이유

`int arr[10];`

일반적인 변수 선언때 메모리 할당은 컴파일 타임에서 이루어짐

근데 크기 더 필요할 경우 선언때 크기값을 더 큰값으로 하는 방법밖에 없음

크기가 유동적이라면 이는 미봉책에 불과함 (매번 크키에 맞게 수정해서 실행할순 없자너)

그렇다면 실행 시에 결정하다 (동적 메모리 할당)

자세한건 여기를 보자

- [[C언어] 동적 메모리 할당 개념 잡기](https://velog.io/@saint6839/C언어-동적-메모리-할당-개념-잡기)

### 4-2. 객체지향에 대한 이해

자바스크립트가 객체기반 언어임

- 객체지향이란

  객체 : 사물(Object)을 나타내는 추상적인 개념

  지향 : ~ 향한다(Oriented) 라는 의미

  모든 사물을 프로그래밍 시키겠다 뭐 이런소리?

객체지향 이전에는 `구조적 프로그래밍`이 있었음 (순차적, 하향식, 폭포수)

구조적 프로그래밍의 문제점은 중간에 문제가 생기면 다시 돌아가기가 힘들었데

객체지향은 `기능` 단위로 프로그래밍 됨

## 5. 추상화과 캡슐화

### 5-1 추상화

> 대상에서 특징만을 뽑아낸 것

개를 추상화 하면

코, 귀, 다리, 꼬리가 있고 (속성)

짖고, 꼬리를 흔든다 (행위)

### 5-2 캡슐화

> 외부에서 내부를 볼 수 없게 하는것

마냥 숨기기만 하는게 아니라

외부에서 데이터를 조작할 인터페이스가 필요함 (인증된)

클래스 안에 있는 것을 메소드, 함수는 범용적으로 부를때 쓴다네
