# 컴퓨터 구조의 설계와 구현

## 컴퓨터 구조

### 하드웨어 구성

- 중앙처리장치 : CPU (central processing unit)

  - 제어장치 : 명령어를 해석하여 그 실행에 필요한 제어신호를 발생

  - ALU (산술논리연산 장치) : 산술 및 연산 수행

  - 레지스터 : 연산의 대상 및 연산결과를 저장

- 주기억장치 : Memory (RAM/ ROM)

- 보조기억장치 : Storage (HDD, SSD, optical discs, magnetic, tapes, ...)

- 입출력장치 : I/O Devices (keyboard, mouse, display, printer, network, ...)

### 명령어 집합 구조(ISA)

- ISA(Instruction Set Architecture)

  마이크로프로세스가 인식해서 기능을 이해하고 실행할 수 있는 명령어 (기계어 명령어) 들의 집합

  - 중앙처리장치가 표현할 수 있는 자료형

  - 중앙처리장치에 명령할 수 있는 기계어 명령어들의 종류

  - 주소지정법

- 기계어 명령어는 사람이 알아보기 불편하므로 주로 어셈블리로 표현

- 같은 ISA 를 가지는 컴퓨터에는 같은 프로그램을 실행 가능

### 마이크로아키텍쳐 (Microarchitecture)

> 명령어 집합구조를 물리적으로 구현한 것

- 같은 ISA를 서로 다른 Microarchitecture로 구현하기도 함

  ex: Intel 과 AMD

### 기능 및 종류

- 산술 및 논리 연산

  ADD, SUB, MUL, DIV

  AND, OR, NOT

- 데이터 전송

  레지스터/ 메모리/ 입출력

- 실행 제어

  프로그램의 실행을 순차에서 벗어나서 실행

  브랜치, 점프

- 기타

  - 인터럽트 제어

  - 명령실행 권한 변경

### CISC, RISC

- CISC (Complex Instruction Set Computing)

  여러 동작을 한꺼번에 할 수 있는 여러가지의 명령어들을 제공

  명령어들의 형식과 길이가 다양하고, 주소 지정 방식도 다양

  주로 마이크로프로그램 제어 방식의 프로세서로 구성

- RISC (Reduced Instruction Set Computing)

  고정된 길이의 최소 종류의 명령어들을 제공

  주소지정 방식 최소화, Load/Store 방식의 메모리 접근

  한 클록 사이클에 하나의 명령을 실행할 수 있도록 설계

### 명령어 파이프라인

모든 명령어들의 실행을 동일한 단계들로 나누고

한 클록 사이클에 한단계씩 진행하도록 하여

동시에 여러 명령어들의 서로 다른 단계를 실행

### 기억장치 구성

### 메모리 주소 공간

메모리 내의 매 바이트(byte) 마다

독립된(그리고 연속된) 주소를 부여하는 것이

일반적인 컴퓨터 메모리 조직

## 프로그램의 번역과 실행

- 프로그래밍 언어 분류

  기계어 >> 어셈블리 >> 고수준 프로그래밍 언어

### 프로그램의 번역

원시코드 >> 어셈블리 코드 >> 목적 코드

- 원시코드

  일반적으로 고수준 프로그래밍 언어

  개발자가 작성

  어느 기계에 실행할지에 따라 크게 다르지 않음

- 어셈블리 코드

  프로그래밍 언어에 따라 다른 번역기

  구문 구조를 해석하고 특정 기계를 대상으로 어셈블리 코드 생성

- 목적코드

  기계가 이해할수 있는 명령어들의 집합

  0과 1만으로 이루어진 코드 나열

  서로 다른 컴퓨터에서 다르게 표현

  어셈블리에 의해서 거의 1대 1 번역

### 프로그램 번역/ 실행의 두가지 모델

- 컴파일러

  원시코드 > 번역기(컴파일러) > 실행코드 > 실행

  번역을 실행 이전에 해서 코드를 공들여 최적화 할 수 잇음

  코드 실행 효율 좋음

- 인터프리터

  원시코드 > 번역기(인터프리터) > 실행

  다른 컴퓨터로 옮겨 실행하는 것에 편리함

  대화형 개발이 가능

이 두가지 장점을 택한 방법들도 이용됨 (java, python > 가상기계 이용)

- 가상기계를 이용한 실행 모델

  원시코드 > 컴파일러 > 바이트코드 > 인터프리터(가상기계) > 실행

  장점 : 컴파일러에 의한 코드 최적화 가능, 실행 효율 높음

  동일한 모델의 가상기계를 운용하는 어떠한 컴퓨터에서도 실행 가능

### 컴파일러와 링커/ 로더

- 링커

  여러 덩어리의 목적코드를 연결

  보통 컴파일러와 함께 실행

  서로 다른 모듈 사이의 주소 상호 참조를 해결

- 로더

  운영체제 일부로서 프로그램 실행 담당

  프로그램 파일을 저장장치로부터 메모리 적재

  동적 적재 문제도 해결 (동적 적재 : 필요할때 가져다 쓰는거ㄴ)

### 라이브러리

많은 프로그램들이 공히 이용하는 기능을 담당하는 소프트웨어를 모듈화하여 준비해 둔 것

## 운영체제의 역할과 구조

- 시스템 소프트웨어

  컴퓨터 시스템을 운영하거나 소프트웨어 개발을 지원하는데 이용되는 소프트웨어 모음

  운영체제, 컴파일어, 링커/ 로더, 시스템 운영 도구들

- 응용 소프트웨어

  컴퓨터 시스템이 응용될 분야에따른 기능을 수행하도록 만들어진 소프트웨어

  워드프로세서, 스프레드 시트, 웹 브라우저, 게임 등등

### 운영체제

컴퓨터 시스템이 살아가기 위하여 반드시 필요한 소프트웨어(의 모음)

- 운영체제 역활

  - 컴퓨터 시스템의 자원 관리

    프로세스 시간, 메모리 공간, 입출력 장치, 파일

  - 시스템 자원을 활용할 수 있는 기능 제공

    텍스트 에디터

    시스템 관리 도구

    소프트웨어 개발 도구

### 운영체제 커널

- 운영체제의 핵심 부분에 위치

  - 시스템의 모든 측면에서 완전한 권한을 가지고 있음

  - 사용자(및 프로세스) 간 충돌 또는 침해로부터의 보호와 함께

    효율적이면서 공정한 자원 공유 (배분) 담당

- 시스템 자원에 대한 완전한 제어권을 구사하기 위해서 하드웨어의 지원이 필요

- 커널 외의 부분(사용자라고 부름) 을 이루는 코드는 시스템 자원 접근을 위해서 커널 서비스 이용

  대표적으로 시스템 콜

### 시스템 콜

- 운영체제 커널이 제공하는 서비스에 대한 응용 프로그램의 요청을 가능하게 하기 위한 프로그래밍 인터페이스

- 응용프로그램은 보통 고급 API (라이브러리) 함수들을 통하여 시스템 호출에 접근

- 시스템 콜의 호출은 프로세스의 실행 문맥 (context) 을 특권 모드(privileged mode) 로 전환시킴

## 프로세스 관리와 스케줄링

프로세스란?

> 컴퓨터 시스템에서 CPU 및 메모리를 이용하여 실행 중인 작업

- 컴퓨터 시스템에서 실행되는 거의 모든 소프트웨어는 하나 이상의 프로세스를 이룸

- 프로세스는 생명주기를 가지며, 이것은 운영체제가 관리

- 프로그램 != 프로세스

  프로그램은 실행이 준비된 소프트웨어 덩어리

  프로세스는 지금 실행하고 있는 소프트웨어의 생명체

### 프로세스 상태

### 프로세스와 스레드

이미지

- 동시성

  동시성을 가지는 일들을 처리하는데에는 동기화가 필요

### 스케줄링

어느순간 작업을 수행할 것인지를 결정하는 문제

- 효율성과 공정성 사이의 이해득실 관계

  - 응답시간을 최소화

  - 시스템 처리율 극대화

    문맥 전환의 오버헤드를 고려하면 응답시간과 같은 기준이 아님

  - 공정성을 해지지 말것

- 종류

  - FCFS(First-come First-served) : 선착순

  - SJF(Shortest Job First) : 지금 할 수 있는 것들 중 가장 적은순

  - SRTF(Shortest Remaining Time First)

    새로운 작업이 현재것보다 빨리 할 수 있음 `문맥전환(preemption)`

    매순간, 남아있는 작업량이 가장 적은 것을 선택

  - 평균응답 시간(average response time) 측면에서 최적의 알고리즘

    수학적으로 증명,

## 메모리와 입출력 관리

### 컴퓨팅 시스템 자원의 추상화

- 프로세스: CPU 시간에 대한 추상화

  각 프로세스(실행중인 프로그램)은 자신에게 CPU 시간이 전체 중 일부가 주어지는 것으로 가상할 수 있음

- 가상메모리 : 메모리 공간에 대한 추상화

  각 프로세스는 전체 주소공간을 모두 자신에게 할당된 메모리로 사용할 수 있는것으로 가상할 수 있음

- 파일시스템 : 입출력 장치들을 일관된 인터페이스로 추상화

  각 프로세스는 실제 입출력 장치의 동작 방식과는 무관하게 파일을 조작하는 것과 동일한 일관된 방법을 통하여

  서로 다른 장치의 입출력을 이용할 수 있음

### 메모리 계층 구조와 가상 메모리

### 가상메모리

MMU

프로세스에게 메모리를 할당해주고 프로세스가 반환하는 메모리를 "이용 가능한것" 으로 관리하고

서로 다른 프로세스가 남의 메모리를 침범하지 못하도록 하는 일은, 모두 운영체제의 몫

### 페이징에 의한 가상메모리 주소 변환

### 요구 페이징(Demand Paging)

- 페이지 폴트(page fault)를 줄이는 것은 전체시스템 성능 향상에서 매우 중요한 일

  - 지역성에 근거하여 메모리 페이지들을 저장 장치로부터 읽어들여 메모리에 적재

  - 캐시 메모리의 관리와 유사한 방법

    교체 기법에 LRU(least recently used) 및 이를 근사화한 알고리즘 적용

- 참조의 지역성

  - 시간적 지역성

    지금 참조된 주소는 가까운 미래에 또 다시 참조될 가능성이 높음

  - 공간적 지역성

    지금 참조된 주소는 가까운 주소가 미래에 참조될 가능성이 높음

### 파일시스템

- 저장장치(storage) 는 입출력장치와는 조금 다른 특성을 가짐

  - 단지 데이터를 입출력하는 것 외에 메모리 서브시스템의 일부(가상메모리)로서의 역활/ 기능을 가지기 때문

- 운영체제는 저장장치를 파일시스템으로 추상화

  - 디스크 드라이브는 입출력 장치관리 방법에 의하여 관리되며, 이 장치를 이용하여 `파일`의 형태로

    추상화된 데이터집합을 이용할 수 있는 운영체제의 일부(파일시스템)를 구현

- 많은 종류의 장치들을 파일로 간주하는 추상화방식을 통하여 일관된 방법으로 장치에 접근할 수 있도록 관리 (특히 UNIX 계열)

  - 장치관리자가 커널의 문맥에서 실행하면서 각 장치의 입력/출력 및 기타 제어를 담당
